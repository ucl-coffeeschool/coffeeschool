<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Lesson 5 - Coffee School</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link href="css/main.css" rel="stylesheet">
    <link href="css/prism.css" rel="stylesheet">
    <script src="js/prism.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>
    <!-- nav stuff. -->
    <nav>
        <a href="index.html">Home</a>
        <a href="sections.html" class="active">Sections</a>
        <a href="about.html">About</a>
    </nav>

    <div class="nagbar" style="display:none">
        <p>Your code doesn't seem to do what we're looking for. Check it and try again!</p>
        <i class="fa fa-close"></i>
    </div>

    <!-- Main content. -->
    <div class="overlay" style="display:none">
        <span class="closeButton"><i class="fa fa-close"></i></span>
            <h1>Section cleared!</h1>
            <h2>You're a rockstar. Nice one you.</h2>
            <a href="sections.html">View Sections</a>
    </div>
    <div class="main">
        <header>
            <div id="menu-button"><i class="fa fa-bars"></i></div>
            <h1>Coffee School <i class="fa fa-code"></i><em>Game Lesson Three - Using Game States</em></h1>
        </header>
        <div class="container">
            <div class="flex-container div-half">
                <h2>Code Editor <button id="code-compile"><i class="fa fa-play"></i> Update</button><span id="syntax-msg"></span>
                        <button id="sectionButton" onClick="window.location = 'sections.html'"><i class="fa fa-home"></i> Sections</button></h2>

                <div id="codeEditor">// Creating environment variables
var playerSize = 10;
var sceneWidth = 300, sceneHeight = 150;
var groundHeight = 10;
var playAreaHeight = (sceneHeight - groundHeight);
// Create the variables to track player movement
var playerVel = 0; // Stores the player&#x27;s velocity
var g = 0.4;       // The constant acceleration cause by &quot;gravity&quot;
// Object width!
var objectWidth = 2 * playerSize;
// Obstacle Counter
var obstacleCounter = 0;

// Sets the background colour
Crafty.background(&quot;#ADD8E6&quot;);

Crafty.defineScene(&quot;Start&quot;, function() {
  // Introductory text
  Crafty.e(&quot;2D, DOM, Text&quot;)
      .attr({x: sceneWidth/2, y: sceneHeight/2, w: 100, h: 20})
      .text(&quot;Press &#x27;space&#x27; to begin&quot;)
      .css({&quot;text-align&quot;:&quot;center&quot;})

  // &quot;Dummy&quot; player
  Crafty.e(&quot;2D, DOM, Color&quot;)
      .attr({x: 30,y: 30, w: playerSize, h: playerSize})
      .color(&quot;#ff0000&quot;)
      // Handle any keypress events
      .bind(&quot;KeyDown&quot;, function(event) {
          // If the key pressed is the space bar then move to the &quot;Game&quot; scene
          if(event.key == Crafty.keys.SPACE) {
              Crafty.enterScene(&quot;Game&quot;);
          }
      });

  // Dummy ground
  Crafty.e(&quot;2D, DOM, Color&quot;)
      .attr({x: 0, y: playAreaHeight, w: sceneWidth, h: groundHeight})
      .color(&quot;#00ff00&quot;);
});

// Enter the start scene
Crafty.enterScene(&quot;Start&quot;);

// Our &quot;Game Over&quot; screen
Crafty.defineScene(&quot;GameOver&quot;, function(){
    // The text to display the game over message
    Crafty.e(&quot;2D, DOM, Text&quot;)
      .attr({x: sceneWidth/2, y: sceneHeight/2, w: 100, h: 20})
      .text(&quot;Game Over!&quot;)
      .textFont({size: &#x27;14px&#x27;, weight: &#x27;bold&#x27;});

    // Dummy ground
    Crafty.e(&quot;2D, DOM, Color&quot;)
      .attr({x: 0, y: playAreaHeight, w: sceneWidth, h: groundHeight})
      .color(&quot;#00ff00&quot;);
});

Crafty.defineScene(&quot;Game&quot;, function() {
  // Create the ground!
  Crafty.e(&quot;Solid, 2D, DOM, Color&quot;)
      .attr({x: 0,
             y: playAreaHeight,
             w: sceneWidth,
             h: groundHeight})
      .color(&quot;#00ff00&quot;);

  // Create our player&#x27;s base entity
  Crafty.e(&quot;Collision, 2D, DOM, Color&quot;) // Specifying the components to add
      .attr({x: 30, y: 30, w: playerSize, h: playerSize}) // Specifying the dimensions and the point to draw from
      .checkHits(&quot;Solid&quot;)
      .color(&quot;#ff0000&quot;) // Specifying the colour of the rectangle
      .bind(&quot;EnterFrame&quot;, function() { // Binds the &quot;EnterFrame&quot; event to the entity
          if(this.y &lt; 0) {
            playerVel = g; // Prevent the player from going above the game screen
          }
          else {
            playerVel += g; // Adds the &quot;gravitational acceleration&quot; to the player&#x27;s velocity
          }

          this.y += playerVel; // Change the player entities y position based on the player velocity
      })
      .bind(&quot;KeyDown&quot;, function(event) { // Binds the &quot;KeyDown&quot; event to our player entity
          if(event.key == Crafty.keys.SPACE){ // If the key is the spacebar then &quot;flap&quot;
              playerVel = -5; // Sets the player&#x27;s speed and direction to go upwards
          }
      })
      .bind(&quot;HitOn&quot;, function() {
        Crafty.enterScene(&quot;GameOver&quot;);
      })
      .bind(&quot;EnterFrame&quot;, function() {
          Crafty(&quot;Obstacle&quot;).each(function() {
              if(this.x &lt; -objectWidth) {
                  this.destroy();
              }
              else {
                  this.x -= 3;
              }

          });

          if(obstacleCounter &gt; 100){
              obstacleCounter = 0;
              newObstacle();
          }

          obstacleCounter++;

      });
});


function newObstacle()
{
    var randomHeight = Math.floor((Math.random() * (sceneHeight/2)) + (sceneHeight/3));
    var bottomOfTopHalf = playAreaHeight - randomHeight;
    var topOfBottomHalf = bottomOfTopHalf + (4 * playerSize);

    // Create the top half of the pipe
    Crafty.e(&quot;Obstacle, 2D, DOM, Color, Solid&quot;)
        .attr({x: sceneWidth,
               y: 0,
               w: objectWidth,
               h: bottomOfTopHalf})
        .color(&quot;#003319&quot;);

    // Create the bottom half of the pipe
    Crafty.e(&quot;Obstacle, 2D, DOM, Color, Solid&quot;)
        .attr({x: sceneWidth,
               y: topOfBottomHalf,
               w: objectWidth,
               h: playAreaHeight - topOfBottomHalf})
        .color(&quot;#003319&quot;);
}
</div>
            </div>
            <div class="flex-container div-half">
                <div class="flex-container">
                    <h2>Preview</h2>
                    <div class="div-content" id="game-container">
                    </div>
                    <h2>Console Log:</h2>
                    <div class="div-content" id="log-div"> </div>
                    <div class="div-content">
                        <h1>Game Lesson Three - Using Game States</h1>
                        <h2 id="part-2-creating-the-game-over-screen-and-keeping-score">Part 2: Creating the Game Over Screen and Keeping Score</h2>
<h3 id="goal-keeping-track-of-score-and-displaying-it-to-the-player-">Goal: Keeping track of score and displaying it to the player.</h3>
<p>With a game over screen there is now the possibility to show the player some information about their last play. A standard piece of information to show to the player both during the game and after they lose (or complete) is what score they managed to achieve. Score in games such as these is usually dictated by how many obstacles have been cleared by the player, so we’ll use that in this example.</p>
<p>There are other types of information in our game which could be recorded and used to calculate score or show to the player such as the time they managed to last before losing and how many jumps they used. After this example have a go at recording and using these different bits of information to show the player more about their last play.</p>
<p>In the “Game Lesson Two” we used Craftys component functionality to give our obstacles a label to allow for accessing them. The component label given to the obstacles was used to move all the obstacles and detect when an obstacle was out of play and it’s entity should be destroyed.</p>
<p>To keep track of score we don’t need to add much to our already existing code. As it is, when an obstacle goes off screen two entities are destroyed. Because these two entities make up an obstacle, each entity deletion with the component “Obstacle” should increase the score by half a point (0.5).</p>
<p>To allow score to be accessed by both the “Game” scene and the “GameOver” scene we can keep track of it in a variable <code>score</code> at the top of our code. Each time a game starts the score should be set to 0 so that should happen at the start of the “Game” scene.</p>
<p>Let’s create our score variable:</p>
<pre><code class="lang-javascript">var score = 0; // Create the score variable

// Start, GameOver and Game scenes would be here
</code></pre>
<p>Now that we have our score variable we need to reset the score at the start of each play through the game. To do that we just need to set <code>score = 0</code> at the beginning of the “Game” scene.</p>
<pre><code class="lang-javascript">Crafty.defineScene(&quot;Game&quot;, function() {

    score = 0; // Reset the score

    // Main game lives here
})
</code></pre>
<p>With this in place we can count up the score when obstacles are destroyed! To do this we just need to increase <code>score</code> by 0.5 when we delete each entity that makes up half of the obstacle being destroyed.</p>
<pre><code class="lang-javascript">if(this.x &lt; -objectWidth){
  score += 0.5; // Increase the score by half a point before deleting the entity
  this.destroy();
}
</code></pre>
<p>This results in the player’s recorded score going up by 1 point every time they clear an obstacle (it goes off the stage).</p>
<p>To show the player what score they achieved in their last play-through we can create a text entity and place it in the corner of the screen. This bit involves two steps:</p>
<ol>
<li>Creating the entity to display the text to the player.</li>
<li>Updating the displayed text for the entity each frame.</li>
</ol>
<p>Creating the entity which displays text to the player follows the same process that we used for the text in the start screen and the end screen. The values shown in the code snippet below are just an example of the sort of values you can use, so feel free to play about and put the text where on the screen you think it should be!</p>
<pre><code class="lang-javascript">// score reset is here

Crafty.e(&quot;2D, DOM, Text&quot;)
  .attr({x: 5,
         y: 10,
         w: 100,
         h: 20})
  .text(&quot;Score: &quot; + score)
  .textFont({size: &#39;14px&#39;, weight: &#39;bold&#39;});

// Rest of main game lives here
</code></pre>
<p>There’s a problem with just leaving the code at that, as Crafty entities don’t update their <code>text</code> property when variables they use change. This means that we have to update the score text ourselves! One way of doing this is binding the “EnterFrame” event to the entity that we’re using and updating the text each game loop:</p>
<pre><code class="lang-javascript">Crafty.e(&quot;2D, DOM, Text&quot;)
  .attr({x: 5,
         y: 10,
         w: 100,
         h: 20})
  .text(&quot;Score: &quot; + score)
  .textFont({size: &#39;14px&#39;, weight: &#39;bold&#39;})
  .bind(&quot;EnterFrame&quot;, function() {
    this.text(&quot;Score: &quot; + score); // Here we&#39;re just accessing the entities .text property and using it to update the displayed text
  });
</code></pre>
<p>Now we have an updating score that allows the player to see how well they’re doing in their play-through! However, if the player loses then they won’t be able to see what score they achieved so we should also show it to them on the game over screen.</p>
<p>Showing the player their score once the game is over is a simple matter of changing the <code>.text</code> property of the entity in the “GameOver” scene because we made our score globally accessible:</p>
<pre><code class="lang-javascript">// Our text element in the &quot;GameOver&quot; scene
Crafty.e(&quot;2D, DOM, Text&quot;)
  .attr({x: sceneWidth, y: sceneHeight/2, w: 100, h: 20})
  .text(&quot;Game Over! Your score was: &quot; + score)
  .textFont({size: &#39;14px&#39;, weight: &#39;bold&#39;});
</code></pre>
<p>With that change our game now allows the player to keep track of how well they’re doing while playing, while also letting them see how well they did once the game ends. <em>But wait, what if we want to allow the player to play again without refreshing the page?</em></p>
<p>All we need to do to allow this is to move some of our game variables and bind an extra <code>KeyDown</code> event (within the “GameOver” scene). Moving the <code>playerVel</code> declaration and the <code>obstacleCounter</code> declaration into the game loop means that when the player starts another play through the game variables are reset.</p>
<p>Moving the variable declarations:</p>
<ol>
<li>Remove <code>var playerVel = 0;</code> and <code>var obstacleCounter = 0;</code> from the top of our JavaScript.</li>
<li>Declare them at the top of our “Game” scene.</li>
</ol>
<p>This code snippet illustrates the desired placing for the variables to work as intended:</p>
<pre><code class="lang-javascript">Crafty.defineScene(&quot;Game&quot;, function() {
  score = 0; // this is where we reset the player score

  var playerVel = 0; // Making the players velocity only accessible within the game scene - while also resetting it so you don&#39;t get unintended behaviour
  var obstacleCounter = 0; // making the obstacle counter accessible only within the game scene - also resetting it so that obstacles are generated as intended

  // Here be game logic and entities!
});
</code></pre>
<p>Next, letting the player have another play through from the game over screen. To let the player do this we can just bind a <code>KeyDown</code> to our text entity in the “GameOver” scene, using the <code>Crafty.enterScene</code> function.</p>
<pre><code class="lang-javascript">// Our &quot;GameOver&quot; text entity
Crafty.e(&quot;2D, DOM, Text&quot;)
  .attr({x: sceneWidth/2, y: sceneHeight/2, w: 100, h: 20})
  .text(&quot;Game Over! Your score was: &quot; + score)
  .textFont({size: &#39;14px&#39;, weight: &#39;bold&#39;})
  // Here we&#39;re binding the KeyDown event
  .bind(&quot;KeyDown&quot;, function(event){
    // If the player presses space, go to the game scene
    if(event.key == Crafty.keys.SPACE){
      Crafty.enterScene(&quot;Game&quot;); // Go back into the &quot;Game&quot; scene.
    }
  });
</code></pre>
<p>This lets the player start another play through from the game over screen with a fresh game state. With that last change you’ve just finished a fully functioning “flappy bird” style game!</p>

                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script defer>
        $(document).ready(function() {
    $('#nextLesson, #sectionButton').addClass("lessonComplete");
});

var codeTest = function() {
    return "notest";
}

    </script>
    <!-- Editor (ace) -->

    <script type="text/javascript" src="https://rawgithub.com/craftyjs/Crafty/release/dist/crafty-min.js"></script>
    <script src="https://cdn.jsdelivr.net/ace/1.2.3/min/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/main.js" type="text/javascript" charset="utf-8"></script>
</body>

</html>
